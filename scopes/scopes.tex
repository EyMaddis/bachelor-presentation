\subsection{Scopes}




\begin{frame}
	\begin{itemize}
		\item[]\textbf{Komfortables Debuggen} \\
		\item[]	Einfügen der Jumpfunktion\\
		setzen von Breakpoints\\ 	
	\end{itemize}
	%Mein Thema ist die Einführung einer neuen Funktion.
\end{frame}

\begin{frame}
	\begin{center}
		\includegraphics[scale=0.4]{scopes/Jump1.pdf}
	\end{center}
	% mit der "überspringen" Funktion soll man nicht nur Schrittweise durch den Text gehen können, sondern ganze Codeblöcke überspringen können. Zusätzlich soll die Möglichkeit bestehen, breakpoints zu setzten, bei denen eine normale Simulation anhält.
\end{frame}	

\begin{frame}

	\begin{center}
		\includegraphics[scale=0.4]{scopes/beispiel2.pdf}
	\end{center}
	%Idee: Wir suchen nach Schlagwörtern im Text. 
\end{frame}

\begin{frame}
	\begin{center}
		\includegraphics[scale=0.4]{scopes/beispiel3.pdf}
	\end{center}
	%Wird ein Blockanfang gefunden, gehen wir eine Ebene tiefer in den Laufzeitkeller (Stack). Wird das Ende eines Blockes erkannt, geht man wieder eine Ebene hinauf. Wenn man in der GUI die Funktion "Überspringen" auswählt, wird die Anfangstiefe gespeichert und es wird automatisch durch die Simulation gegangen, bis man an einem Punkt angelangt ist, wo die aktuelle Tiefe kleiner als die Anfangstiefe ist. Bei einer Anfangstiefe von 0 wird nur ein normaler Schritt durchgeführt.
\end{frame}

\begin{frame}

	\begin{itemize}
		\item[]\textbf{Schritt 1: Einfügen der $ break\_point $ Funktion} \\
		\item[]\textbf{Schritt 2: Automatische Blockerkennung und Einfügen der Funktion in den übergebenen Code} \\
	\end{itemize}
	%Was brauchen wir für den ersten Schritt:
\end{frame}

\begin{frame}
	\ \\
	\begin{center}
		\includegraphics[scale=0.5]{scopes/button.pdf}
	\end{center}
	%Zuerst brauchen wir einen Button.
\end{frame}

\begin{frame}
	\begin{itemize}
		\item[]\textbf{Eine Funktion: $break\_point()$} \\
		\item[]\textbf{:point $\rightarrow$ Breakpoint} \\
		\item[]\textbf{:down $\rightarrow$ In den Keller} \\
		\item[]\textbf{:up \ \ $\rightarrow$ \ Aus dem Keller} \\
	\end{itemize}
	%Meine Lösung: die Funktion break\_ point(:arg) mit den Argumenten :
	%:point -> Breakpoint
	%:down -> erhöhung des Scopes
	%up -> verringerung des Scopes
\end{frame}

\begin{frame}
	\ \\
	\begin{center}
		\includegraphics[scale=0.6]{scopes/preprocessor.pdf}
	\end{center}
	%Damit man eine Funktion im Code benutzen kann, müssen wir sie im Preprozessor vordefinieren. Wenn die VM den Code ausführt, soll sie die breakfunktion mit dem ausgesuchten parapeter aufrufen. 
\end{frame}

\begin{frame}
	\inputminted[linenos, frame=lines, label=rubyfunction]{java}{scopes/first.rb}
	%Die Breakfunktion packt einfach das Argument in das aktuelle Paket. Hierzu habe ich einen neuen Paket-Schlüssel definiert: :break (break ist vorgefiniert, deswegen heißt die Funktion break!) 
\end{frame}

\begin{frame}
	\begin{center}
		\includegraphics[scale=0.5]{scopes/stacks.pdf}
	\end{center}
	%Die VM und der Server geben also nur die Argumente an den Client weiter, wo ich eine Variable Stackdeep angelegt hab. Kommt ein Packet mit einem :break Element an, wird nur die Variable hoch oder runter gezählt.
	%Wenn man "überspringen" auswählt, wird die Stack deep gespeichert und die Pakete solange simuliert, bis die Stackdeep kleiner als der gespeicherte Wert ist. 
	%Wenn in einem Paket ein Breakpoint gesetzt werden soll, rufen wir einfach dir Funktion Simulation.stop() auf, die auch ausgeführt wird, wenn man auf den Stop Button drück.
\end{frame}

\begin{frame}
	\begin{itemize}
		\item[]\textbf{Automatische Blockerkennung} \\
		\item[]\textbf{Beispiel: Ruby} \\
	\end{itemize}
	%Jetzt also die automatische Blockerkennung. Als Beispielsprache nehme ich nun Ruby. Die automatische Blockerkennung ist Sprachenabhänging und muss für jede Sprache einzeln programiert werden. 
\end{frame}

\begin{frame}
	\begin{center}
		\includegraphics[scale=0.4]{scopes/beispiel2.pdf}
	\end{center}
	%Ich will die Blöcke erkennen, die mit 'end' beendet werden, also hab ich in einer Liste von Schlagwörtern für Ruby alle relevanten rausgeschrieben.
\end{frame}

\begin{frame}
	\begin{itemize}
		\item[]\textbf{class\\ def\\ module\\ if (unless)\\ while\\ for\\ until\\ do\\ case\\ begin\\ BEGIN\\ END\\}
	\end{itemize}
	%Die Liste ist dann doch etwas länger geworden.
\end{frame}

\begin{frame}
	\begin{center}
	\ \\
		\includegraphics[scale=0.4]{scopes/beispiel4.pdf}
	\end{center}
	%Es stellt sich also die Frage, wo ich die Funktion in den Code einfügen möchte. Zuerst dachte ich, direkt nach dem Schlüsselwort, bei einer Schleife würden wir dann jedoch immer wieder die Funktion aufrufen.
\end{frame}

\begin{frame}
	\begin{center}
		\ \\ \ \\
		\includegraphics[scale=0.4]{scopes/beispiel5.pdf}
	\end{center}
	%Also dachte ich, direkt in der Zeile vor dem Schlüsselwort. Definiert man aber eine Funktion und ruft diese später auf, wird die Zeile vor der Funktion natürlich nicht ausgeführt. Also musste ich meine List unterteilen.
\end{frame}

\begin{frame}
	\begin{center}
		\begin{tabular}{c|c}
			\textbf{Vor} & \textbf{Hinter} \\ 
			\hline 
			\textbf{for} & \textbf{def} \\ 
			\textbf{until} & \textbf{class} \\
			\textbf{while} & \textbf{module} \\
			\textbf{if/unless} & \textbf{BEGIN} \\
			\textbf{do} & \textbf{END} \\
			\textbf{case} &  \\
		\end{tabular}
	\end{center}
	%bei den Operatoren, bei denne ich die break_down Funktion vor dem Öffnen des Blocks setzt, setzt ich die break_up Funktion hinter das dazugehörige end. Für die unterscheidung der ends benutzte ich eine Liste, zu der ich bei jedem öffnen eines Blockes ein passendes Element hinzufüge und beim schließen das zuletzt hinzugefügte Element untersuche und lösche.
	%da durch return eine Funktion vorzeitig beendet werden kann, muss man auch vor einem return die break Funktion aufrufen.
	%Ein weiteres Problem ist, dass z.B. bei der While Schleife zusätzlich zu dem while ein do gesetzt werden kann. Zur Zeit prüfe ich den Code zuerst auf die Schlüsselwörter, auf die optimal auch ein do folgen kann und erst wenn keines dieser Wörter gefunden wurde prüfe ich auf do.
\end{frame}

\begin{frame}
	\inputminted[linenos, frame=lines, label=Beispiel]{java}{scopes/beispiel.rb}
	%Weitere Fälle müssen untersucht werden: Kommentare und String. Schlüsselwörter, die in solchen Bereichen stehen, müssen ignoriert werden. Und man muss aufpassen, dass man die breakfunktion nicht ausversehen in einen Kommentar oder string einfügt.
	%Zur Zeit suche ich mit der index Funktion nach Kommentaren. Sie liefert die Stelle, an dem ein Zeichen das erste mal vorkommt. Genau davor würde ich dann die Funktion kopieren.
\end{frame}

\begin{frame}
	\begin{itemize}
		\item[]\textbf{Momentane Einschränkungen:}
		\item[]Nur eine break- Funktion pro Zeile
		\item[]Keine Schlagwörter in Strings
		\item[]Keine break- Funktionen in Zeilen mit multiline Strings
		\item[]\textbf{...}
	\end{itemize}
	%Bis jetzt muss man sich an die folgenden Bedingungen halten, damit die Jump Funktion korrekt genutzt werden kann... Da ich noch nicht fertig bin, werden mir bestimmt in den nächsten Wochen weitere Probleme auffallen. In der nächsten Zeit werde ich versuchen, diese Probleme möglichst zu beheben. Idee zu Strings: Codezeile kürzen und gekürzte Zeile überprüfen.
\end{frame}
